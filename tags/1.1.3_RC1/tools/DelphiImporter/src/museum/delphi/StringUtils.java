/**
 *
 */
package museum.delphi;
import java.io.StringWriter;
import java.text.CharacterIterator;
import java.text.StringCharacterIterator;
import java.util.ArrayList;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Element;

/**
 * @author Patrick
 *
 */
public class StringUtils {

	protected static int _debugLevel = 1;

	protected static void debug( int level, String str ){
		if( level <= _debugLevel )
			outputDebugStr( str );
	}

	public static void outputDebugStr( String str ){
		System.out.println( str );
	}

	public static void outputExceptionTrace( Exception e ){
        e.printStackTrace( System.out );
	}

	public static String trimQuotes( String str ) {
		int len = str.length();
		String ret;
		if( str.charAt(0) == '"' ) {
			if( str.charAt(len-1) == '"' )
				ret = str.substring(1, len-1);
			else
				ret = str.substring(1, len);
		} else if( str.charAt(len-1) == '"' )
			ret = str.substring(0, len-1);
		else
			return str;
		debug( 2, "trimQuotes mapping ["+str+"] to ["+ret+"]");
		return ret;
	}

	public static String escapeForDBAndXML(String input) {
		final StringBuilder result = new StringBuilder();
		final StringCharacterIterator iterator = new StringCharacterIterator(input);
		char character =  iterator.current();
		while (character != CharacterIterator.DONE ){
			if((character == '\"')
				||(character == '\'')
				||(character == '\\')
				||(character == '`' )
				||(character == '|' )) {
				result.append('\\');
			}
			result.append(character);
			character = iterator.next();
		}
		return result.toString();
	}

	public static String buildLineFromTokens( ArrayList<String> tokens, int sepChar ){
		StringBuilder sb = new StringBuilder();
		boolean fFirst = true;
		for( String str:tokens ) {
			if( fFirst )
				fFirst = false;
			else
				sb.append(sepChar);
			sb.append(str);
		}
		return sb.toString();
	}

	public static String outputXMLStringForNode( Element el ) {
		try {
	    // Use a Transformer for output
		TransformerFactory tFactory =
	    TransformerFactory.newInstance();
		Transformer transformer = tFactory.newTransformer();

		DOMSource source = new DOMSource(el);
		StringWriter writer = new StringWriter();
		StreamResult result = new StreamResult(writer);
		transformer.setOutputProperty(OutputKeys.METHOD, "html");
		transformer.transform(source, result);
		return writer.toString();
		} catch (TransformerConfigurationException tce) {
		  // Error generated by the parser
		  System.out.println ("* Transformer Factory error");
		  System.out.println("  " + tce.getMessage() );

		   // Use the contained exception, if any
		  Throwable x = tce;
		  if (tce.getException() != null)
		    x = tce.getException();
		  x.printStackTrace();
		} catch (TransformerException te) {
		  // Error generated by the parser
		  System.out.println ("* Transformation error");
		  System.out.println("  " + te.getMessage() );

		  // Use the contained exception, if any
		  Throwable x = te;
		  if (te.getException() != null)
		    x = te.getException();
		  x.printStackTrace();
		}
		return null;
	}

	public static String getBaseDirForPath( String path ) {
		// Find last slash or backslash (to allow for windows paths), to get basepath
    	int iSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
    	return ( iSlash>0 )? path.substring(0, iSlash+1):null;
	}

	/**
	 * Tokenizes an input string according to column info rules.
	 * Also maps all tokens and words to lower case.
	 * @param source input String
	 * @param colInfo columnInfo for this string
	 * @return List of Pairs: first is token, second is words in that token
	 */
	public static ArrayList<Pair<String,ArrayList<String>>> prepareSourceTokens(
			String source, DumpColumnConfigInfo colInfo ) {  //  @jve:decl-index=0:
		ArrayList<Pair<String,ArrayList<String>>> returnList =
						new ArrayList<Pair<String,ArrayList<String>>>();
		// First we apply reduction. This cleans up certain oddities in the source
		String reducedSource = source.toLowerCase();
		for(Pair<String, String> reduce : colInfo.reduceRules) {
			reducedSource = reducedSource.replaceAll(reduce.first, reduce.second);
		}
		// Next, we tokenize with the token separators
		String[] tokens_strings;
		if( colInfo.tokenSeparators.size() == 0 ) {
			// throw new RuntimeException( "No Token separators for column: " + colInfo.name);
			tokens_strings = new String[1];
			tokens_strings[0] = reducedSource;
		} else {
			String regex = "\\||"+colInfo.tokenSeparators.get(0);
			for( int i=1; i<colInfo.tokenSeparators.size(); i++)
				regex += "|"+colInfo.tokenSeparators.get(i);
			tokens_strings = reducedSource.split(regex);
		}
		// Next, we further split up each token on space and certain punctuation and remove the noise items
		// We also build the words list for Colors
		for( int i=0; i< tokens_strings.length; i++ ){
			String token = tokens_strings[i].trim();
			if(token.isEmpty())
				continue;
			// Split into words, but preserve hyphenated words, and embedded single quotes
			ArrayList<String> words = new ArrayList<String>();
			Pair<String,ArrayList<String>> pair = null;
				new Pair<String,ArrayList<String>>(token,words);
			String[] words_strings = token.split("[\\W&&[^\\-\']]");
			if( colInfo.noiseTokens.size() == 0 ){
				pair = new Pair<String,ArrayList<String>>(token,words);
				for( int iW=0; iW<words_strings.length; iW++) {
					String word = words_strings[iW].trim();
					if(word.length()>0)
						words.add(word);
				}
				returnList.add(pair);
			}
			else {
				StringBuilder sb = new StringBuilder();
				for( int iW=0; iW<words_strings.length; iW++)
					if( !colInfo.noiseTokens.contains(words_strings[iW]) ) {
						String word = words_strings[iW].trim();
						if(word.length()>0) {
							if( iW > 0)
								sb.append(' ');
							sb.append(word);
							words.add(word);
						}
					}
				if(sb.length()>0) {
					pair = new Pair<String,ArrayList<String>>(sb.toString(),words);
					returnList.add(pair);
				}
			}
		}
		return returnList;
	}
}
