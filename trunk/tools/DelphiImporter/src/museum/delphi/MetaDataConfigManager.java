/**
 *
 */
package museum.delphi;

import java.io.IOException;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

/**
 * @author pschmitz
 *
 */
public class MetaDataConfigManager {
	private String		cfgFilename = null;
	private Document	colConfigDoc = null;
    private Element		processingInfoNode = null;
    private Element		dbSourceInfoNode = null;

	private static int _debugLevel = 1;

	protected static void debug( int level, String str ){
		if( level <= _debugLevel )
			StringUtils.outputDebugStr(str);
	}

	protected static void debugTrace( int level, Exception e ){
		if( level <= _debugLevel )
			StringUtils.outputExceptionTrace(e);
	}

	public MetaDataConfigManager( String filename ) {
		cfgFilename = filename;
		try {
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
			colConfigDoc = builder.parse("file:"+filename);
			// First, get the root of the column config.
			NodeList nodes = colConfigDoc.getElementsByTagName( "processingInfo" );
			if( nodes.getLength() != 1 ) {  // Should only be one.
				throw new RuntimeException(
						"MetaDataConfigManager: file must have one processingInfo node.");
			}
		    processingInfoNode = (Element)nodes.item(0);

			// Next, get the root of any dbSourceInfo.
			nodes = colConfigDoc.getElementsByTagName( "dbSourceInfo" );
			if( nodes.getLength() > 1 ) {  // Should 0 or 1.
				throw new RuntimeException(
						"MetaDataConfigManager: file can only have one dbSourceInfo node.");
			}
		    dbSourceInfoNode = (Element)nodes.item(0);
        } catch (SAXParseException spe) {
            // Error generated by the parser
            // Use the contained exception, if any
            Exception x = spe;
            if (spe.getException() != null)
                x = spe.getException();
			String tmp = "MetaDataConfigManager: SAXParseException:"
				+"\n  line:"+spe.getLineNumber() + ", uri " + spe.getSystemId()
				+"\n  " + spe.getMessage()
				+"\n  " + x.getMessage();
			debug(1, tmp);
            debugTrace(1, x);
			throw new RuntimeException( tmp );
        } catch (SAXException sxe) {
            // Error generated by this application (or a parser-initialization error)
            Exception x = sxe;
            if (sxe.getException() != null) {
                x = sxe.getException();
            }
			String tmp = "DumpColumnConfigInfo.OpenConfigFile: SAXException parsing config file."
				+"\n"+ x.getMessage();
			debug(1, tmp);
            debugTrace(1, x);
			throw new RuntimeException( tmp );
		} catch( ParserConfigurationException pce ) {
			String tmp = "DumpColumnConfigInfo.OpenConfigFile: Exception parsing config file."
				+"\n"+pce.getMessage();
			debug(1, tmp);
            debugTrace(1, pce);
			throw new RuntimeException( tmp );
        } catch (IOException ioe) {
			String tmp = "DumpColumnConfigInfo.OpenConfigFile: I/O Exception reading config file.\n File: \""
				+filename+"\"\n"+ioe.getMessage();
			debug(1, tmp);
            debugTrace(1, ioe);
			throw new RuntimeException( tmp );
		} catch( RuntimeException e ) {
			String tmp = "DumpColumnConfigInfo.OpenConfigFile: Error encountered reading config file."
				+"\n"+e.getMessage();
			debug(1, tmp);
            debugTrace(1, e);
			throw new RuntimeException( tmp );
		}

	}

	// TODO when we fix DumpColConfigInfo, this will return an object
	protected boolean GetDumpColConfigInfo() {
		DumpColumnConfigInfo.PopulateFromConfigFile(processingInfoNode);
		return true;

	}

	/**
	 * Gets a DBMetaDataReader instance from the configuration information.
	 * Will dispatch to the particular subclass to handle the protocol,
	 * but that is a detail that consumers of this need not worry about.
	 * @return
	 */
	protected DBMetaDataReader GetDBSourceInfo() {
		// Check protocol attributes of dbSourceInfoNode element to choose the subclass.
		// This should ideally be configured, but we'll hard code it for now.
		DBMetaDataReader reader = null;
		if( attribute is sql server )
			reader = new SQLServerMetaDataReader(dbSourceInfoNode);
		return reader;
	}

}
